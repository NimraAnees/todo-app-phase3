# Data Model: Authentication & Security Layer

**Date**: 2026-01-11
**Feature**: Authentication & Security Layer (JWT-based)
**Purpose**: Define database entities and their relationships for authentication

---

## Entity: User

The `User` entity represents a registered user account in the system. Each user has a unique email address and encrypted password credentials.

### Fields

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, NOT NULL, DEFAULT gen_random_uuid() | Unique identifier for the user |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL | User's email address (used for authentication) |
| `password_hash` | VARCHAR(255) | NOT NULL | Bcrypt hash of user's password (never store plain-text) |
| `created_at` | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | Timestamp when user account was created |
| `updated_at` | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | Timestamp when user account was last updated |

### Indexes

```sql
CREATE INDEX idx_users_email ON users(email);
```

**Rationale**: Email lookups occur on every sign-in. Index dramatically improves query performance (O(log n) vs O(n)).

### Constraints

1. **Email Uniqueness**: Enforced at database level via UNIQUE constraint
   - Prevents duplicate registrations
   - Raises exception if violated (handle in application layer)

2. **Email Format**: Validated in application layer (Pydantic)
   - RFC 5322 compliant email regex
   - Example: `user@example.com`

3. **Password Requirements** (enforced in application layer):
   - Minimum 8 characters
   - No maximum (bcrypt handles up to 72 bytes)
   - Complexity requirements optional (not enforced in Phase 2)

4. **Password Hash Storage**:
   - Bcrypt produces 60-character hash
   - VARCHAR(255) allows for future algorithm upgrades (e.g., argon2)

### Validation Rules

**Registration**:
- `email`: Must be valid email format, must not already exist
- `password`: Minimum 8 characters, hashed before storage
- `created_at`, `updated_at`: Auto-generated by database

**Sign-In**:
- `email`: Must exist in database
- `password`: Plain-text input compared against stored `password_hash` via bcrypt verify

**Update** (not in Phase 2 scope):
- `updated_at`: Auto-updated on any field modification

### State Transitions

```text
[New User Input]
       ↓
  Registration
       ↓
  {email, password} → hash(password)
       ↓
  Store: {id (generated), email, password_hash, created_at, updated_at}
       ↓
  [User Record Created]
       ↓
  Sign-In
       ↓
  Retrieve: password_hash by email
       ↓
  Verify: bcrypt.verify(input_password, password_hash)
       ↓
  [Authentication Success/Failure]
```

---

## Entity Relationships

### Phase 2 (Current Scope)

```text
User (standalone entity)
- No relationships in authentication-only phase
- Will relate to Todos in future phases
```

### Future Phases (Reference Only)

```text
User
  ├── 1:N → Todos
  │         (user_id foreign key in todos table)
  │
  └── 1:N → Sessions (if adding session management)
            (user_id foreign key in sessions table)
```

---

## SQLModel Definition (Python)

```python
# backend/app/models/user.py
from sqlmodel import Field, SQLModel
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional

class User(SQLModel, table=True):
    """User entity for authentication."""
    __tablename__ = "users"

    id: UUID = Field(default_factory=uuid4, primary_key=True, nullable=False)
    email: str = Field(sa_column_kwargs={"unique": True}, max_length=255, nullable=False)
    password_hash: str = Field(max_length=255, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)
    updated_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)

    class Config:
        json_schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "email": "user@example.com",
                "password_hash": "$2b$12$KIXxCc8r9c4yN8fL5vXvRO...",
                "created_at": "2026-01-11T12:00:00Z",
                "updated_at": "2026-01-11T12:00:00Z"
            }
        }
```

---

## Pydantic Schemas (Request/Response)

### UserCreate (Registration Request)

```python
# backend/app/schemas/auth.py
from pydantic import BaseModel, EmailStr, Field

class UserCreate(BaseModel):
    """Schema for user registration request."""
    email: EmailStr = Field(..., description="User's email address")
    password: str = Field(..., min_length=8, description="User's password (minimum 8 characters)")

    class Config:
        json_schema_extra = {
            "example": {
                "email": "newuser@example.com",
                "password": "securepassword123"
            }
        }
```

### UserLogin (Sign-In Request)

```python
class UserLogin(BaseModel):
    """Schema for user sign-in request."""
    email: EmailStr = Field(..., description="User's email address")
    password: str = Field(..., description="User's password")

    class Config:
        json_schema_extra = {
            "example": {
                "email": "user@example.com",
                "password": "securepassword123"
            }
        }
```

### UserResponse (API Response)

```python
from uuid import UUID
from datetime import datetime

class UserResponse(BaseModel):
    """Schema for user data in API responses (excludes password_hash)."""
    id: UUID
    email: EmailStr
    created_at: datetime

    class Config:
        json_schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "email": "user@example.com",
                "created_at": "2026-01-11T12:00:00Z"
            }
        }
```

### TokenResponse (Authentication Response)

```python
class TokenResponse(BaseModel):
    """Schema for JWT token response after successful authentication."""
    access_token: str = Field(..., description="JWT access token")
    token_type: str = Field(default="bearer", description="Token type (always 'bearer')")
    user: UserResponse = Field(..., description="User information")

    class Config:
        json_schema_extra = {
            "example": {
                "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "token_type": "bearer",
                "user": {
                    "id": "550e8400-e29b-41d4-a716-446655440000",
                    "email": "user@example.com",
                    "created_at": "2026-01-11T12:00:00Z"
                }
            }
        }
```

---

## Database Migration

### Initial Migration (Alembic or SQLModel)

```sql
-- migrations/001_create_users_table.sql

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);

-- Trigger to auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

### Rollback Migration

```sql
-- migrations/001_rollback.sql

DROP TRIGGER IF EXISTS update_users_updated_at ON users;
DROP FUNCTION IF EXISTS update_updated_at_column();
DROP INDEX IF EXISTS idx_users_email;
DROP TABLE IF EXISTS users;
DROP EXTENSION IF EXISTS "uuid-ossp";
```

---

## Data Validation Summary

| Validation | Layer | Implementation |
|------------|-------|----------------|
| Email format (RFC 5322) | Application | Pydantic `EmailStr` |
| Email uniqueness | Database | UNIQUE constraint |
| Password min length (8 chars) | Application | Pydantic `Field(min_length=8)` |
| Password hashing | Application | bcrypt (passlib) |
| UUID generation | Database | `gen_random_uuid()` |
| Timestamp auto-generation | Database | `DEFAULT NOW()` |
| Timestamp auto-update | Database | Trigger function |

---

## Security Considerations

1. **Password Hash Storage**:
   - ✅ Use bcrypt with work factor 12
   - ✅ Never store plain-text passwords
   - ✅ Never log passwords (even hashed)
   - ✅ Use VARCHAR(255) to allow future algorithm upgrades

2. **Email Privacy**:
   - ✅ Generic error messages for authentication failures
   - ✅ Don't reveal whether email exists during sign-in
   - ✅ Rate limit authentication endpoints (5 attempts per 15 minutes)

3. **User Enumeration Prevention**:
   - ✅ Same error for "email not found" and "wrong password"
   - ✅ Constant-time password verification (bcrypt handles this)
   - ✅ No user count endpoints exposed

4. **Database Security**:
   - ✅ Use parameterized queries (SQLModel/SQLAlchemy handles this)
   - ✅ Apply principle of least privilege to database user
   - ✅ Enable SSL/TLS for database connections

---

## Entity Summary

| Entity | Purpose | Key Fields | Relationships |
|--------|---------|------------|---------------|
| **User** | Stores registered user accounts | id (UUID), email (unique), password_hash | None (Phase 2) |

**Total Entities**: 1 (User only in authentication phase)

**Future Entities** (Reference):
- Todo (will have foreign key to User)
- Session (optional, if adding session management)

---

**Data Model Completed**: 2026-01-11
**Next**: Generate API contracts (`/contracts/auth-api.yaml`)
